use crate::sfc::Sfc;

/// Extremely simple stub codegen that emits a Rust module with raw blocks.
/// Later, youâ€™ll compile `<template>` into VNodes and `<style>` into native styles.
pub fn to_stub_rs(sfc: &Sfc, component_name: &str) -> String {
    let t = sfc
        .template
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let ss = sfc
        .script_setup
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let s = sfc
        .script
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let st = sfc.style.as_ref().map(|b| b.content.as_str()).unwrap_or("");

    let name = sanitize_ident(component_name);
    let open = "{";
    let close = "}";

    // Use normal string (not raw) and inject literal braces via {open}/{close}
    format!(
        "// @generated by velox-sfc (stub)
pub mod {name} {open}
    pub const TEMPLATE: &str = r#\"{template}\"#;
    pub const SCRIPT_SETUP: &str = r#\"{script_setup}\"#;
    pub const SCRIPT: &str = r#\"{script}\"#;
    pub const STYLE: &str = r#\"{style}\"#;
{close}
",
        name = name,
        open = open,
        close = close,
        template = t,
        script_setup = ss,
        script = s,
        style = st
    )
}

fn sanitize_ident(raw: &str) -> String {
    let mut out = String::with_capacity(raw.len());
    for (i, ch) in raw.chars().enumerate() {
        if (i == 0 && ch.is_ascii_digit()) || !is_ident_char(ch) {
            out.push('_');
        } else {
            out.push(ch.to_ascii_lowercase());
        }
    }
    if out.is_empty() { "_comp".into() } else { out }
}

fn is_ident_char(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '_' || ch == '-'
}
