use crate::sfc::Sfc;

/// Extremely simple stub codegen that emits a Rust module with raw blocks.
/// Later, youâ€™ll compile `<template>` into VNodes and `<style>` into native styles.
pub fn to_stub_rs(sfc: &Sfc, component_name: &str) -> String {
    let t = sfc
        .template
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let ss = sfc
        .script_setup
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let s = sfc
        .script
        .as_ref()
        .map(|b| b.content.as_str())
        .unwrap_or("");
    let st = sfc.style.as_ref().map(|b| b.content.as_str()).unwrap_or("");

    let name = sanitize_ident(component_name);
    let open = "{";
    let close = "}";

    // Build output manually to allow embedding script_setup as raw Rust.
    let mut out = String::new();
    out.push_str("// @generated by velox-sfc (stub)\n");
    out.push_str(&format!("pub mod {} {}\n", name, open));
    out.push_str(&format!("    pub const TEMPLATE: &str = r#\"{}\"#;\n", t));
    out.push_str(&format!("    pub const SCRIPT_SETUP: &str = r#\"{}\"#;\n", ss));
    out.push_str(&format!("    pub const SCRIPT: &str = r#\"{}\"#;\n", s));
    out.push_str(&format!("    pub const STYLE: &str = r#\"{}\"#;\n", st));
    if !ss.is_empty() {
        out.push_str("    #[allow(dead_code)]\n    pub mod script_rs {\n        #![allow(unused)]\n");
        out.push_str("        use super::*;\n");
        // Insert user code as-is; they are writing Rust.
        for line in ss.lines() {
            out.push_str("        ");
            out.push_str(line);
            out.push_str("\n");
        }
        out.push_str("    }\n");
    }
    out.push_str(close);
    out.push_str("\n");
    out
}

fn sanitize_ident(raw: &str) -> String {
    let mut out = String::with_capacity(raw.len());
    for (i, ch) in raw.chars().enumerate() {
        if (i == 0 && ch.is_ascii_digit()) || !is_ident_char(ch) {
            out.push('_');
        } else {
            out.push(ch.to_ascii_lowercase());
        }
    }
    if out.is_empty() { "_comp".into() } else { out }
}

fn is_ident_char(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '_' || ch == '-'
}
